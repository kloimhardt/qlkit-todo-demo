(ns qlkit-todo\little-clojure\core)

(def mapv map)

(defn writefile[fname txt]
  (let [myfile (php/fopen fname "a")
        code (php/fwrite myfile (str txt "\n"))
        _ (php/fclose myfile)]
    txt))

(defn eprint [e]
  (writefile "klmlog.txt" (print-str e))
  e)

(defn into-set [coll]
  (let [empty (set)]
    (reduce push empty coll)))

(defn set-contains? [st el]
  (if (= (set) (intersection st (set el))) nil el))

(defn into-table [coll]
  (let [empty @{}]
    (reduce (fn [m [k v]] (put m k v)) empty coll)))

(defn into-map [coll]
  (reduce (fn [m [k v]] (put m k v)) {} coll))

(defn assoc [m k v]
  (put m k v))

(defn dissoc [mp & ks]
  (reduce (fn[m k] (unset m k)) mp ks))

(defn apply [f args]
  (first (mapv f (mapv vector args))))

(defn atom [val]
  (let [a @{:atom-val val}] a))

(defn swap! [a fun]
  (let [val (fun (:atom-val a))]
    (put a :atom-val val)
    val))

(defn reset! [a val]
  (put a :atom-val val)
  val)

(defn doall [x] x)

(defn deref [a] (:atom-val a))

(defn atom? [a]
  (and (table? a) (:atom-val a)))

(def eval-atom (atom nil))

(defn read-edn [edn-string]
  (let [fname (str "tmp" (php/uniqid))
        phel-string edn-string
        # deprecated!! (php/str_replace "{" "@{" edn-string)
        # this read-edn function also lacks removal of commas
        ]
    (writefile fname (str "(reset! eval-atom " phel-string ")"))
    (load fname)
    (php/unlink fname)
    (deref eval-atom)))

(defn write-edn [phel-data]
  (->> (print-str phel-data)
       (php/str_replace "@{" "{")
       (php/str_replace "@[" "[")))

(defn get-fn1 [f argsv]
  (if (and (table? f) (= (into-set (keys f)) (set :dispatch-fn :fn-map)))
    (let [@{:fn-map fn-map :dispatch-fn dispatch-fn} f
          dispatch-val (apply dispatch-fn argsv)]
      @{:fun (get fn-map dispatch-val) :dispatch-val dispatch-val})
    @{:fun f :dispatch-val nil}))

(defn get-fn [f & args]
  (:fun (get-fn1 f args)))

(defn dispatch [f & args]
  (let [@{:fun fun :dispatch-val dispatch-val} (get-fn1 f args)]
    (if fun
      (apply fun args)
      (eprint (str "No method in multimethod for: " dispatch-val)))))

(defn remove-all-methods [mfun]
  (put mfun :fn-map @{}))

(defn defmethod [mfun dispatch-key fn]
  (put (get mfun :fn-map) dispatch-key fn))

(defn defmulti [dispatch-fn]
  @{:dispatch-fn dispatch-fn
    :fn-map @{}})


# ------------ tests ------------------
(def multif (defmulti identity))

(defmethod multif :a (fn [] "a"))

(defmethod multif :b (fn [] "b"))

(defn tests []
  [(= (apply + [3 4]) 7)
   (= (into-set [3 4 4]) (set 3 4))
   (= (set-contains? (set 3 4) 4) 4)
   (= (set-contains? (set 3 4) 2) nil)
   (= (into-table [[:a 1] [:b 2]]) @{:a 1 :b 2})
   (= (into-map [[:a 1] [:b 2]]) {:a 1 :b 2})
   (= (assoc {:a 1 :b 2} :c 3)
      {:a 1 :b 2 :c 3})
   (= (dissoc {:a 1 :b 2 :c 4} :a :b)
      {:c 4})
   (let [ a (atom 8)]
     (= (deref a)
        8)
     (= (swap! a inc)
        9)
     (= (deref a)
        9)
     (= (reset! a 2)
        2)
     (= (deref a)
        2))
   (= (read-edn "[1 {:a 7}]")
      [1 {:a 7}])
   (= (write-edn [1 {:a 7}])
      "[1 {:a 7}]")
   (= (dispatch multif :a) "a")

   (= (dispatch multif :b) "b")
   ])
